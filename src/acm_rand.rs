use rand::{seq::SliceRandom, Rng};
use std::ops::Range;

pub trait AcmRand: Rng {
    fn gen_scale(&mut self, scale: usize) -> usize {
        let low = (0.9 * scale as f64).ceil() as usize;
        self.gen_range(low..=scale)
    }
    fn gen_ordered_pair(&mut self, range: Range<usize>) -> (usize, usize) {
        let l = self.gen_range(range.clone());
        let r = self.gen_range(range);
        (l.min(r), l.max(r))
    }
    fn gen_distinct_pair(&mut self, range: Range<usize>) -> (usize, usize) {
        let l = self.gen_range(range.clone());
        let r = self.gen_range(range.start..range.end - 1);
        (l, r + (r >= l) as usize)
    }
    /// Generate a random tree with n vertices, indexed from `0` to `n-1`.
    /// The tree is generated by randomly permuting the vertices and connecting each vertex to another from the previous `dis` vertices. In this way, you can control the diameter of tree.
    /// The tree is returned as a list of edges.
    fn gen_tree(&mut self, n: usize, dis: usize) -> Vec<(usize, usize)> {
        let mut perm: Vec<_> = (0..n).collect();
        perm.shuffle(self);
        let mut edges = Vec::new();
        for (i, &v) in perm.iter().enumerate().skip(1) {
            edges.push((v, perm[self.gen_range((i - dis).max(0)..i)]));
        }
        edges.shuffle(self);
        edges
    }

    /// Used to generate multi-group data.
    /// Higher cohesiveness will lead to more unbalanced groups that the first group will have more elements.
    fn gen_groups(
        &mut self,
        t: usize,
        sum: usize,
        lower_bound: usize,
        cohesiveness: f64,
    ) -> Vec<usize> {
        assert!(
            (0.0..=1.0).contains(&cohesiveness),
            "Cohesiveness must be in [0, 1]."
        );
        assert!(t * lower_bound <= sum, "Sum is too small.");
        let mut groups = vec![lower_bound; t];
        for _ in 0..sum - t * lower_bound {
            if self.gen_bool(cohesiveness) {
                groups[0] += 1;
            } else {
                groups[self.gen_range(0..t)] += 1;
            }
        }
        groups
    }
}
impl<T> AcmRand for T where T: Rng {}
