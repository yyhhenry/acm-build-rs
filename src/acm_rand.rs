use rand::{seq::SliceRandom, Rng};
use std::ops::Range;

pub trait AcmRand: Rng {
    fn gen_scale(&mut self, scale: usize) -> usize {
        let low = (0.9 * scale as f64).ceil() as usize;
        self.gen_range(low..=scale)
    }
    fn gen_ordered_pair(&mut self, range: Range<usize>) -> (usize, usize) {
        let l = self.gen_range(range.clone());
        let r = self.gen_range(range);
        (l.min(r), l.max(r))
    }
    fn gen_distinct_pair(&mut self, range: Range<usize>) -> (usize, usize) {
        let l = self.gen_range(range.clone());
        let r = self.gen_range(range.start..range.end - 1);
        (l, r + (r >= l) as usize)
    }
    /// Generate a random tree with n vertices, indexed from `0` to `n-1`.
    /// The tree is generated by randomly permuting the vertices and connecting each vertex to another from the previous `dis` vertices. In this way, you can control the diameter of tree.
    /// The tree is returned as a list of edges.
    fn gen_tree(&mut self, n: usize, dis: usize) -> Vec<(usize, usize)> {
        let mut perm: Vec<_> = (0..n).collect();
        perm.shuffle(self);
        let mut edges = Vec::new();
        for (i, &v) in perm.iter().enumerate().skip(1) {
            edges.push((v, perm[self.gen_range((i - dis).max(0)..i)]));
        }
        edges.shuffle(self);
        edges
    }
}
impl<T> AcmRand for T where T: Rng {}
